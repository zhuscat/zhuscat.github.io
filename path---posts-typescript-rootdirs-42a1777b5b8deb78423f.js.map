{"version":3,"sources":["webpack:///path---posts-typescript-rootdirs-42a1777b5b8deb78423f.js","webpack:///./.cache/json/posts-typescript-rootdirs.json"],"names":["webpackJsonp","532","module","exports","data","markdownRemark","html","frontmatter","title","date","tags","fields","slug","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,ixFAAg2EC,aAAmiBC,MAAA,6BAAAC,KAAA,gBAAAC,MAAA,oBAAuFC,QAAWC,KAAA,2BAAiCC,aAAgBD,KAAA","file":"path---posts-typescript-rootdirs-42a1777b5b8deb78423f.js","sourcesContent":["webpackJsonp([71622063944478],{\n\n/***/ 532:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>在 TypeScript 中可以利用 rootDirs 指定虚拟目录，若不了解，可以阅读<a href=\\\"https://www.typescriptlang.org/docs/handbook/module-resolution.html\\\">Module Resolution · TypeScript</a>。</p>\\n<h2>解析步骤</h2>\\n<p>在上面链接的文章中有一个假象的国际化场景，通过配置 <code class=\\\"language-text\\\">rootDirs</code>，编译器可以解析并不存在的相对模块导入，配置如下所示，其中，并不存在一个文件夹为 <code class=\\\"language-text\\\">src/${locale}</code>。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-json\\\"><code class=\\\"language-json\\\"><span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token property\\\">\\\"compilerOptions\\\"</span><span class=\\\"token operator\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token property\\\">\\\"rootDirs\\\"</span><span class=\\\"token operator\\\">:</span> <span class=\\\"token punctuation\\\">[</span>\\n      <span class=\\\"token string\\\">\\\"src/zh\\\"</span><span class=\\\"token punctuation\\\">,</span>\\n      <span class=\\\"token string\\\">\\\"src/de\\\"</span><span class=\\\"token punctuation\\\">,</span>\\n      <span class=\\\"token string\\\">\\\"src/#{locale}\\\"</span>\\n    <span class=\\\"token punctuation\\\">]</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>假设我们的项目所在地是 <code class=\\\"language-text\\\">/dev/project</code>，有 <code class=\\\"language-text\\\">/dev/project/src/zh/messages.ts</code> 文件，有 <code class=\\\"language-text\\\">/dev/project/src/de/messages.ts</code> 文件以及 <code class=\\\"language-text\\\">/dev/project/src/index.ts</code> 文件，在进行了上述的配置之后，在 <code class=\\\"language-text\\\">/dev/project/src/index.ts</code> 文件中导入 <code class=\\\"language-text\\\">import messages from ‘./#{locale}/messages</code>，该模块可以被成功解析，实际上编译器认为模块为 <code class=\\\"language-text\\\">/dev/project/src/zh/messages.ts</code>，这是怎么做到的呢？</p>\\n<p>编译时，在 <code class=\\\"language-text\\\">index.ts</code> 中的导入语句的相对路径会转换为绝对路径，即 <code class=\\\"language-text\\\">/dev/project/src/#{locale}/messages</code>，接着遍历 <code class=\\\"language-text\\\">rootDirs</code> 列表，找出与这个路径相比最长的前缀匹配路径，最终确定的是 <code class=\\\"language-text\\\">/dev/project/src/#{locale}/</code>，将 <code class=\\\"language-text\\\">/dev/project/src/${locale}/messages</code> 与 <code class=\\\"language-text\\\">/dev/project/src/#{locale}/</code> 相同的部分去掉，确定要加载的为 <strong>messages</strong>，候选位置为 <code class=\\\"language-text\\\">/dev/project/src/${locale}/messages</code>，编译器将会按照相对路径模块导入的解析方法进行模块解析，不过 <code class=\\\"language-text\\\">/dev/project/src/${locale}/</code> 目录并不存在，于是编译器会从 <code class=\\\"language-text\\\">rootDirs</code> 列表从上到下进行遍历（除去之前选定的那个目录），然后将 <strong>messages</strong> 与路径进行拼接，新的尝试的路径为 <code class=\\\"language-text\\\">/dev/project/src/zh/</code>，模块候选位置为 <code class=\\\"language-text\\\">/dev/project/src/zh/messages</code>，在此处找到了模块，因此将 <code class=\\\"language-text\\\">/dev/project/src/zh/messages.ts</code> 作为模块解析结果。</p>\\n<h2>需要注意的</h2>\\n<ol>\\n<li><code class=\\\"language-text\\\">rootDirs</code> 对编译输出并没有影响，只是让编译器知道模块的含义。</li>\\n</ol>\\n<p><strong>注</strong>：在 TypeScript 2.8 下进行的测试</p>\",\"frontmatter\":{\"title\":\"TypeScript rootDirs 是怎么工作的\",\"date\":\"June 08, 2018\",\"tags\":[\"TypeScript\",\"配置\"]},\"fields\":{\"slug\":\"/typescript-rootdirs/\"}}},\"pathContext\":{\"slug\":\"/typescript-rootdirs/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---posts-typescript-rootdirs-42a1777b5b8deb78423f.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>在 TypeScript 中可以利用 rootDirs 指定虚拟目录，若不了解，可以阅读<a href=\\\"https://www.typescriptlang.org/docs/handbook/module-resolution.html\\\">Module Resolution · TypeScript</a>。</p>\\n<h2>解析步骤</h2>\\n<p>在上面链接的文章中有一个假象的国际化场景，通过配置 <code class=\\\"language-text\\\">rootDirs</code>，编译器可以解析并不存在的相对模块导入，配置如下所示，其中，并不存在一个文件夹为 <code class=\\\"language-text\\\">src/${locale}</code>。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-json\\\"><code class=\\\"language-json\\\"><span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token property\\\">\\\"compilerOptions\\\"</span><span class=\\\"token operator\\\">:</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token property\\\">\\\"rootDirs\\\"</span><span class=\\\"token operator\\\">:</span> <span class=\\\"token punctuation\\\">[</span>\\n      <span class=\\\"token string\\\">\\\"src/zh\\\"</span><span class=\\\"token punctuation\\\">,</span>\\n      <span class=\\\"token string\\\">\\\"src/de\\\"</span><span class=\\\"token punctuation\\\">,</span>\\n      <span class=\\\"token string\\\">\\\"src/#{locale}\\\"</span>\\n    <span class=\\\"token punctuation\\\">]</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>假设我们的项目所在地是 <code class=\\\"language-text\\\">/dev/project</code>，有 <code class=\\\"language-text\\\">/dev/project/src/zh/messages.ts</code> 文件，有 <code class=\\\"language-text\\\">/dev/project/src/de/messages.ts</code> 文件以及 <code class=\\\"language-text\\\">/dev/project/src/index.ts</code> 文件，在进行了上述的配置之后，在 <code class=\\\"language-text\\\">/dev/project/src/index.ts</code> 文件中导入 <code class=\\\"language-text\\\">import messages from ‘./#{locale}/messages</code>，该模块可以被成功解析，实际上编译器认为模块为 <code class=\\\"language-text\\\">/dev/project/src/zh/messages.ts</code>，这是怎么做到的呢？</p>\\n<p>编译时，在 <code class=\\\"language-text\\\">index.ts</code> 中的导入语句的相对路径会转换为绝对路径，即 <code class=\\\"language-text\\\">/dev/project/src/#{locale}/messages</code>，接着遍历 <code class=\\\"language-text\\\">rootDirs</code> 列表，找出与这个路径相比最长的前缀匹配路径，最终确定的是 <code class=\\\"language-text\\\">/dev/project/src/#{locale}/</code>，将 <code class=\\\"language-text\\\">/dev/project/src/${locale}/messages</code> 与 <code class=\\\"language-text\\\">/dev/project/src/#{locale}/</code> 相同的部分去掉，确定要加载的为 <strong>messages</strong>，候选位置为 <code class=\\\"language-text\\\">/dev/project/src/${locale}/messages</code>，编译器将会按照相对路径模块导入的解析方法进行模块解析，不过 <code class=\\\"language-text\\\">/dev/project/src/${locale}/</code> 目录并不存在，于是编译器会从 <code class=\\\"language-text\\\">rootDirs</code> 列表从上到下进行遍历（除去之前选定的那个目录），然后将 <strong>messages</strong> 与路径进行拼接，新的尝试的路径为 <code class=\\\"language-text\\\">/dev/project/src/zh/</code>，模块候选位置为 <code class=\\\"language-text\\\">/dev/project/src/zh/messages</code>，在此处找到了模块，因此将 <code class=\\\"language-text\\\">/dev/project/src/zh/messages.ts</code> 作为模块解析结果。</p>\\n<h2>需要注意的</h2>\\n<ol>\\n<li><code class=\\\"language-text\\\">rootDirs</code> 对编译输出并没有影响，只是让编译器知道模块的含义。</li>\\n</ol>\\n<p><strong>注</strong>：在 TypeScript 2.8 下进行的测试</p>\",\"frontmatter\":{\"title\":\"TypeScript rootDirs 是怎么工作的\",\"date\":\"June 08, 2018\",\"tags\":[\"TypeScript\",\"配置\"]},\"fields\":{\"slug\":\"/typescript-rootdirs/\"}}},\"pathContext\":{\"slug\":\"/typescript-rootdirs/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/posts-typescript-rootdirs.json\n// module id = 532\n// module chunks = 71622063944478"],"sourceRoot":""}
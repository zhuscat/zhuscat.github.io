{"data":{"markdownRemark":{"html":"<h2>window.onerror</h2>\n<p><code class=\"language-text\">window.onerror</code> 是顶层的错误处理函数，大部分抛出的未被处理的错误可以在这里进行统一处理。如下所示：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">window<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onerror</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">msg<span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">,</span> row<span class=\"token punctuation\">,</span> col<span class=\"token punctuation\">,</span> error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 处理各种事情，如错误上报</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>另外，如果在函数中 <code class=\"language-text\">return true</code> 的话，错误不会继续向上抛出，也就是不会再浏览器控制台出现 <code class=\"language-text\">Uncaught Error</code> 这些提示。</p>\n<p>当然，<code class=\"language-text\">window.onerror</code> 不是万能灵药，有如下限制：</p>\n<ol>\n<li>Promise 抛出的错误无法处理</li>\n<li>跨域脚本中的错误会直接显示成 <code class=\"language-text\">Script Error</code>，这样一来无法定位错误</li>\n<li>比如说在 HTML 中请求一个不存在的资源，如 <code class=\"language-text\">&lt;img src=&quot;./404.png&quot;&gt;</code>，这也是一个错误，不过 <code class=\"language-text\">window.onerror</code> 也是不能处理到的。</li>\n</ol>\n<p>当然，上面的问题也有一定的解决方案。</p>\n<p>首先说一下跨域脚本问题，第一个解决办法是将脚本同源化，另外就是设置 CORS 策略：</p>\n<p>1.给 <code class=\"language-text\">script</code> 标签加上 <code class=\"language-text\">crossorign</code>，假设 <code class=\"language-text\">http://127.0.0.1:8080</code> 跟当前页面不同源</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://127.0.0.1:8080<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">crossorign</span><span class=\"token punctuation\">></span></span><span class=\"token script\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>2.对服务器进行相关设置</p>\n<p>设置 <code class=\"language-text\">Access-Control-Allow-Origin</code> 为 <code class=\"language-text\">*</code> 或者对应的源</p>\n<p>另外，对于指定相应源的 <code class=\"language-text\">Access-Control-Allow-Origin</code>，一个小知识点是关于脚本的缓存的，我们需要设置 <code class=\"language-text\">Vary: Origin</code> 来根据 <code class=\"language-text\">Orign</code> 区分缓存，这样一来就不会出现类似 <code class=\"language-text\">http://127.0.0.1:8080</code> 请求脚本，结果响应的头部中的 <code class=\"language-text\">Access-Controll-Allow-Origin</code> 为 <code class=\"language-text\">http://127.0.0.1:3000</code> 的问题了。</p>\n<h2>Promise 错误的统一处理</h2>\n<p>上面说到 Promise 的错误是无法通过 <code class=\"language-text\">window.onerror</code> 处理的，我们通过另一种方式进行统一处理：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'unhandledrejection'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 进行各种处理</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>promise<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 产生错误的 promise</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>reason<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 异常原因或者 reject 的内容</span>\n  <span class=\"token comment\">// 如果想要阻止继续抛出，即会在控制台显示 `Uncaught(in promise) Error` 的话，调用以下函数</span>\n  event<span class=\"token punctuation\">.</span><span class=\"token function\">preventDefault</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2>HTML 中网络请求错误</h2>\n<p>通过以下方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">window<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'error'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>注意第三个参数，即在捕获阶段进行日志的捕获，这种方案的缺点是只能知道这个错误发生了，但是错误发生的原因什么的无法进一步知道，错误的内容大概如下所示（请求不存在的图片资源返回了404）：</p>\n<p><img src=\"https://i.loli.net/2018/11/17/5befc59987bf6.png\" alt=\"img-404-error\"></p>\n<h2>One more thing</h2>\n<p>现在一般会对代码进行压缩混淆，这样一来代码中出错得到的名称、行数、列数等信息会和源代码中有出入，这个时候可以一同生成 <code class=\"language-text\">sourcemap</code>，然后可以通过压缩文件报出的错误信息和 <code class=\"language-text\">sourcemap</code> 结合来得出源代码中相应的信息。</p>\n<h2>进一步阅读</h2>\n<ol>\n<li><a href=\"https://github.com/joeyguo/blog/issues/13\">脚本错误量极致优化-监控上报与Script error</a></li>\n<li><a href=\"https://github.com/joeyguo/blog/issues/14\">脚本错误量极致优化-让脚本错误一目了然</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000011602203\">前端魔法堂——异常不仅仅是try/catch</a></li>\n</ol>","frontmatter":{"title":"前端错误小知识","date":"November 03, 2017","tags":["前端","JavaScript"]},"fields":{"slug":"/posts/about-front-end-error/"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/about-front-end-error/"}}
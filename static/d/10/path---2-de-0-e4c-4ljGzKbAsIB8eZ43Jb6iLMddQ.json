{"pageContext":{"isCreatedByStatefulCreatePages":false,"group":[{"node":{"id":"3b62db15-3331-53b3-9c48-12572cbce033","timeToRead":2,"frontmatter":{"title":"Thoughts on Styled Components","date":"Jul 18, 2017","tags":["前端","React","CSS","Styled Components","CSS in JS"]},"fields":{"slug":"/posts/thoughts-on-styled-components/"},"excerpt":"<p>随着组件化的盛行，一些人开始使用 CSS in JS 的方案，目前比较流行的就是 Styled Components，为什么这种方案会被一些人接受并使用呢？我想从动机出发谈谈这个方案。</p>\n<p>在组件化的思维下，很多人会发现，自己写的样式只会在某个组件下使用，比如我写了一个特定的 Button，那么这些样式只会在这个 Button 下使用，这个样式不会给一个列表项，不会给一个标题，在这种情况下，下面这种代码是很常见的：</p>"}},{"node":{"id":"ba66a1b8-f5ee-58fa-9309-087e3433c578","timeToRead":2,"frontmatter":{"title":"Tree Shaking 真的有效吗","date":"Jul 14, 2017","tags":["前端","webpack","rollup"]},"fields":{"slug":"/posts/does-tree-shaking-work/"},"excerpt":"<p>其实 Tree Shaking 出来已经挺久了，不过我还是最近才了解的。</p>\n<p>Tree Shaking 是一个在 Rollup 中提出的概念，之后在 webpack 2 中也得到了实现。其作用是，比如说我依赖于某个模块的一部分，使用 Tree Shaking 可以只引入我依赖的那部分，其他部分可以去掉。</p>"}},{"node":{"id":"b63cfd34-5f33-5d5e-b2a8-e223b86a5b8f","timeToRead":1,"frontmatter":{"title":"Rollup 小记","date":"Jul 09, 2017","tags":["前端","打包"]},"fields":{"slug":"/posts/note-of-rollup/"},"excerpt":"<p>Rollup 是一个模块打包工具，其利用了 ES6 模块的特性，只将需要的代码进行打包，通过这种方式可以大大减小打包的体积（不用打包整个），官方称这个特性为 Tree Shaking。另外，Webpack 2 也支持了 Tree Shaking，因此 Tree Shaking …</p>"}},{"node":{"id":"a3746459-937e-54b5-b4f5-427d73f5672b","timeToRead":4,"frontmatter":{"title":"XSS Protection Summary","date":"May 01, 2017","tags":["前端安全","XSS","前端","XSS 防范"]},"fields":{"slug":"/posts/xss-protection/"},"excerpt":"<h2>分类</h2>\n<p>XSS 攻击分为 <strong>反射型</strong> 、<strong>存储型</strong> 和 <strong>DOM Based XSS</strong></p>\n<h3>反射型 XSS</h3>\n<p>反射型 XSS 是把用户的输入反射回浏览器所造成的 XSS 攻击，比如说本来网页上有一个表单让用户填用户名，用户提交表单之后返回的响应将用户填写的用户名显示出来。这种类型的攻击，一般攻击者的攻击手段为构造一个 URL 让用户去点击，当用户点击了这个 URL 之后，攻击才能成功。</p>"}},{"node":{"id":"2a5a5163-2f80-56eb-b4cd-0a87e30a6e48","timeToRead":1,"frontmatter":{"title":"异步文件上传","date":"Mar 12, 2017","tags":["JavaScript","前端"]},"fields":{"slug":"/posts/async-file-upload/"},"excerpt":"<h2>使用 iframe 进行文件的异步上传</h2>\n<p>使用 <code class=\"language-text\">iframe</code> 进行文件的异步上传的基本思想是在表单上传的时候，创建一个 <code class=\"language-text\">iframe</code> 元素，并将表单的 <code class=\"language-text\">target</code> 属性设置为创建的 <code class=\"language-text\">iframe</code> 窗口，这样，上传结束返回的数据会到 <code class=\"language-text\">iframe</code> 窗口里面，页面也不会发生转跳。</p>\n<p>废话不多说，来看看代码：</p>\n<p>首先是基本的表单</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>form</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>myform<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">method</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>post<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">enctype</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>multipart/form-data<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">action</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/someurl<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>file<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>myfile<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>submit<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>form</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>接着再看看 <code class=\"language-text\">JavaScript</code> 代码：</p>"}},{"node":{"id":"ba6af279-7c81-5436-ae9f-7ea857e4315c","timeToRead":1,"frontmatter":{"title":"drag","date":"Feb 27, 2017","tags":["JavaScript","HTML5","HTML"]},"fields":{"slug":"/posts/drag/"},"excerpt":"<h2>简述</h2>\n<p>当拖动某一个元素的时候，将会先后触发 <code class=\"language-text\">dragstart</code>，<code class=\"language-text\">drag</code>，<code class=\"language-text\">dragend</code> 事件。</p>\n<p>当某个元素被拖到有效放置目标上时，先后触发 <code class=\"language-text\">dragenter</code>，<code class=\"language-text\">dragover</code>，<code class=\"language-text\">drop</code>或<code class=\"language-text\">dragleave</code>。</p>\n<p>某些元素不允许被放置，这个时候取消这些元素 <code class=\"language-text\">dragenter</code> 和 <code class=\"language-text\">dragover</code> 的默认行为就可以将该元素转为可被放置的目标。</p>\n<p>另外，一些元素有默认的放置行为，这个时候，将 <code class=\"language-text\">drop</code> 的默认行为去除就行了。</p>\n"}},{"node":{"id":"177ca62a-6e5c-5ca6-9c38-842a21f86817","timeToRead":1,"frontmatter":{"title":"加号操作符","date":"Feb 19, 2017","tags":["前端","JavaScript"]},"fields":{"slug":"/posts/add-operator/"},"excerpt":"<p>加法操作符的规则：</p>\n<ol>\n<li>如果操作符中有一个是对象，将其转换为原始值</li>\n<li>如果操作数中有一个是字符串，将另一个也转换为字符串，然后连接</li>\n<li>其他情况下，将两个操作数转换为数字并执行加法运算</li>\n</ol>\n<p>首先看一下第一条规则，如果操作符中有一个是对象，将其转换为原始值，那么，是如何转换的呢？</p>\n<ol>\n<li>如果对象是 <code class=\"language-text\">Date</code> 类型的话，使用 <code class=\"language-text\">toString()</code> 转换为字符串</li>\n<li>其他对象的话会先调用 <code class=\"language-text\">valueOf()</code>，如果返回的是一个原始值得话，则使用这个原始值，否则进入第三部</li>\n<li>调用 <code class=\"language-text\">toString()</code> 方法</li>\n</ol>"}},{"node":{"id":"66ba46eb-8219-5d29-a06f-e355703e5301","timeToRead":1,"frontmatter":{"title":"mongoose Cannot overwrite model once compiled","date":"Jan 05, 2017","tags":["mongoose","mongodb","JavaScript","chokidar","isomorphic"]},"fields":{"slug":"/posts/solve-problem-cannot-overwrite-model-once-compiled/"},"excerpt":"<p>之前使用了 <a href=\"https://github.com/wssgcg1213/koa2-react-isomorphic-boilerplate\">koa2-react-isomorphic-boilerplate</a> 作为编写前后端同构应用，但是使用这个 boilerplate 的时候出现了一个问题：我使用了一个库 <code class=\"language-text\">mongoose</code>，每次在 <code class=\"language-text\">development</code> 模式下修改代码的时候就会抛出错误，错误原因就是 <code class=\"language-text\">Cannot overwrite model once compiled.</code>，然后只能自己重启服务器。</p>\n<p>然后就就想着要不就修改代码之后重启服务器吧。之后又参考了几个前后端同构的 boilerplate，自己写了个 boilerplate，大概就是服务器端代码修改时候自动重启，客户端代码修改进行热替换。然而，这带来的一个问题是客户端代码修改之后，当刷新页面时候服务端返回的html与…</p>"}},{"node":{"id":"f74ddd01-27f6-5bd7-8d21-5ddc8a7b2341","timeToRead":5,"frontmatter":{"title":"解决 Property key of ObjectProperty got \"BooleanLiteral\" 的问题","date":"Jan 04, 2017","tags":["实践","问题排查","Webpack","JavaScript","HMR"]},"fields":{"slug":"/posts/solve-problem-property-key-of-objectproperty/"},"excerpt":"<p>今天在写 <a href=\"https://github.com/zhuscat/react-koa-isomorphic-boilerplate\">react-koa-isomorphic-boilerplate</a>，期间出现了一个问题，错误原因是 <code class=\"language-text\">Property key of ObjectProperty expected node to be of a type [&quot;Identifier&quot;,&quot;StringLiteral&quot;,&quot;NumericLiteral&quot;] but instead got &quot;BooleanLiteral&quot;</code>，很快就找到错误所在的地方，但是一直不知道如何解决这个错误，然后通过各种尝试总算是解决了这个错误，但是还是不知道错误的根本原因是什么，找个时间研究一下，下面就详细介绍一下这个问题的解决办法吧。</p>"}},{"node":{"id":"9ce584af-5a9b-5897-a376-bd824d1fce35","timeToRead":1,"frontmatter":{"title":"2016年我的影视与书籍","date":"Dec 31, 2016","tags":["生活","总结","电影","书籍"]},"fields":{"slug":"/posts/2016-movie-book/"},"excerpt":"<p>新的一年就要来了，想起博客开通也有1年多的时间了吧。年末，写篇文章总结一下这一年来我看的影片与书吧。</p>\n<!-- more -->\n<h2>电影</h2>\n<p>大部分电影都比较满意，毕竟看之前稍稍看了一下评分。</p>\n<h4>低俗小说</h4>\n<p>荒谬，低俗，电影的开头和结尾还是连在一起的，看了之后，爽。</p>\n<h4>奇幻森林</h4>\n<p>特效很好，剧情一般，保护大自然。</p>\n<h4>疯狂动物城</h4>"}}],"pathPrefix":"","first":false,"last":false,"index":2,"pageCount":8,"additionalContext":{}}}
webpackJsonp([0xc4ab4d0d9404],{516:function(n,s){n.exports={data:{markdownRemark:{html:'<h2>什么是 Promise</h2>\n<blockquote>\n<p>Promise是抽象异步处理对象以及对其进行各种操作的组件。</p>\n</blockquote>\n<p>使用 Promise 可以有效的避免写多个层次的回调函数。</p>\n<h2>初体验</h2>\n<p>首先看一下使用回调函数进行异步操作的写法。</p>\n<p><code class="language-text">getSomethingFromNetwork</code> 是一个虚构的函数，其功能是异步从网络中获取内容。</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token function">getSomethingFromNetwork</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> resp<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 处理错误</span>\n  <span class="token punctuation">}</span>\n  <span class="token comment">// 对获取的结果进行进一步的处理</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p>那用 Promise 会怎么写呢？</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token function">getSomethingFromNetworkPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\npromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>\n<span class="token keyword">function</span><span class="token punctuation">(</span>resp<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 对获取的结果进行进一步的处理</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 处理错误</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p>是否很容易理解呢？</p>\n<p>其实，一个新的 API，<code class="language-text">fetch</code> 返回的就是 Promise 对象，该 API 的功能与 <code class="language-text">XMLHttpRequest</code> 类似，进行异步的网络请求。</p>\n<p>简单地看看这个 API 是怎么使用的吧：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'http://localhost:8080/api/tasks\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resp <span class="token operator">=></span> resp<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>json <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p>这里用到了 ES2015 的箭头函数。</p>\n<p>关于 fetch API 的内容可以参考：</p>\n<p><a href="http://www.w3ctech.com/topic/854">【翻译】这个API很“迷人”——(新的Fetch API)</a></p>\n<p>接下来就让我们了解一下 Promise 的具体内容。</p>\n<!-- more -->\n<h2>构造器</h2>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token comment">// 进行异步的处理</span>\n  <span class="token comment">// 然后在适当的时机调用 `resolve` 或者 `reject`</span>\n  <span class="token comment">// 当操作成功的时候调用 `resolve`</span>\n  <span class="token comment">// 当操作失败的时候调用 `reject`</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<h2>状态</h2>\n<p>Promise 对象有三个状态:</p>\n<ol>\n<li>Fulfilled(完成) 调用 <code class="language-text">resolve</code></li>\n<li>Rejected(拒绝) 调用 <code class="language-text">reject</code></li>\n<li>Pending(不是 Fullfilled 和 Rejected 时的状态)</li>\n</ol>\n<p>状态转换：</p>\n<p>Pending -> Fufilled | Rejected</p>\n<h2>实例方法</h2>\n<h3>Promise#then</h3>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onFullfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span></code></pre>\n      </div>\n<p>Promise 对象会在操作成功的时候调用 <code class="language-text">resolve</code>，失败的时候调用 <code class="language-text">reject</code>，而这个这两个函数就是在 <code class="language-text">then</code> 中指定的。Promise 中可以将任意多个方法使用链式调用的方法写在一起。</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>func1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>func2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>func3<span class="token punctuation">)</span></code></pre>\n      </div>\n<p><code class="language-text">catch</code> 是 Promise 对象的另一个方法，在下面会讲到，值得注意的是，<code class="language-text">then</code> 或者 <code class="language-text">catch</code> 返回的是一个全新的 Promise 对象，这与 <code class="language-text">jQuery</code> 的链式调用不同，<code class="language-text">jQuery</code> 实现链式调用是通过返回 <code class="language-text">this</code>，而 Promise 则会返回一个全新的 Promise 对象，这一点要特别注意。</p>\n<h3>Promise#catch(onRejected)</h3>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">promise<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span></code></pre>\n      </div>\n<p><code class="language-text">catch</code> 其实就是 <code class="language-text">then</code> 方法的一个特殊情况:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span></code></pre>\n      </div>\n<h2>静态方法</h2>\n<h3>Promise.all</h3>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span> promise2<span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">[</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 处理 result1, result2</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">[</span>err1<span class="token punctuation">,</span> err2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 处理错误</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p><code class="language-text">Promise.all</code> 接受一个由 Promise 对象组成的数组，返回一个 Promise 对象，只有当数组中的所有 Promise 对象都变成完成状态后，该 Promise 对象才会变成完成状态。<code class="language-text">onFullfilled</code> 与 <code class="language-text">onRejected</code> 接收的参数也是一个数组，其顺序与 Promise 对象数组里的顺序相同。</p>\n<h3>Promise.race</h3>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>promise1<span class="token punctuation">,</span> promise2<span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 处理成功状体</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 处理错误状态</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p><code class="language-text">Promise.race</code> 用法与 <code class="language-text">Promise.all</code> 相同，只不过在传入的 Promise 对象数组中有一个完成就会调用后续的方法。值得注意的是，<code class="language-text">Promise.race</code> 在数组中一个 Promise 对象变为完成状态之后取消执行。ES6 Promises 规范中也没有取消 promise 对象执行的概念</p>\n<h3>Promise.resolve</h3>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">Promise.resolve(66)\n// 相当于\nnew Promise(function(resolve) {\n  resolve(66)\n})</code></pre>\n      </div>\n<h3>Promise.reject</h3>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">Promise.reject(new Error(&#39;Some Error&#39;))\n// 相当于\nnew Promise(function(undefined, reject) {\n  reject(new Error(&#39;Some Error&#39;))\n})</code></pre>\n      </div>\n<h2>链式调用</h2>\n<p>前面在说 <code class="language-text">Promise#then</code> 的时候已经提到了链式调用了，也说到了每次调用返回的是一个全新的 Promise 对象，现在我们再更加详细地看看链式调用的细节。</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">increment</span> <span class="token operator">=</span> value <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> value <span class="token operator">+</span> <span class="token number">1</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> <span class="token function-variable function">double</span> <span class="token operator">=</span> value <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> value <span class="token operator">*</span> <span class="token number">2</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> <span class="token function-variable function">log</span> <span class="token operator">=</span> value <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> <span class="token function-variable function">logError</span> <span class="token operator">=</span> err <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">let</span> promise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n\npromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>increment<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>double<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>logError<span class="token punctuation">)</span>\n<span class="token comment">// 输出：4</span></code></pre>\n      </div>\n<p>链式调用通过函数返回的值进行参数的传递，上面的例子首先调用  <code class="language-text">increment</code>，<code class="language-text">value</code> 变为2，接着调用 <code class="language-text">double</code>， <code class="language-text">value</code> 变为 4，接着调用 <code class="language-text">log</code>，输出 4。</p>\n<p>前一个函数返回的值会经过 <code class="language-text">Promise.resolve</code> 的包装返回，然后下一个 <code class="language-text">Promise#then</code> 方法中的函数就能接收到前一个函数返回的值了，这就是 Promise 链式调用的细节。</p>\n<h2>推荐写法</h2>\n<p><strong>注：</strong>该推荐写法是本人通过阅读其他一些教程的推荐方法与自己平时自己的一些实践所得，并不一定是客观意义上的最好写法</p>\n<h3>捕捉错误</h3>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>func1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>func2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>func3<span class="token punctuation">)</span></code></pre>\n      </div>\n<p>只在 <code class="language-text">then</code> 中写一个函数，用 <code class="language-text">catch</code> 捕获错误。</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 看看下面两种捕获错误的方法有什么区别</span>\npromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>func1<span class="token punctuation">,</span> func2<span class="token punctuation">)</span> <span class="token comment">// 1</span>\npromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>func1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>func2<span class="token punctuation">)</span> <span class="token comment">// 2</span></code></pre>\n      </div>\n<p>看看上面代码，有什么区别呢？</p>\n<p>先看看1，如果 <code class="language-text">func1</code> 中出现错误，<code class="language-text">func2</code> 并不会执行。</p>\n<p>再看看2，如果 <code class="language-text">func1</code> 中出现错误，会执行 <code class="language-text">func2</code>。</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 写成这样就知道是怎么回事了</span>\npromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>func1<span class="token punctuation">,</span> func2<span class="token punctuation">)</span> <span class="token comment">// 1</span>\npromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>func2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span> func2<span class="token punctuation">)</span></code></pre>\n      </div>\n<p>如果使用第一种写法，在逻辑上的确出现了错误，单并没有任何代码去处理该错误，这显然并不是很好的写法。而使用 <code class="language-text">catch</code> 代码更加清晰简洁。</p>\n<h3>抛出错误</h3>\n<p>有两种方法可以调用到 <code class="language-text">onRejected</code> 函数，一种是抛出异常的方式：</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">\'some info\'</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p>另一种就是调用 <code class="language-text">reject</code> (传入的 <code class="language-text">reject</code> 参数)</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token function">reject</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span></code></pre>\n      </div>\n<p>使用第二种方法的做法比较好，因为有其他情况会抛出异常，如果为了去调用 <code class="language-text">onRejected</code> 函数抛出异常，但其他抛出异常也会调用到 <code class="language-text">onRejected</code>，无法很好地区分主动抛出，还是其他的异常。</p>\n<h3>在 then 中进行 reject</h3>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token comment">// 摘录自《JavaScript Promise迷你书（中文版）》 文后有链接</span>\n<span class="token keyword">var</span> onRejected <span class="token operator">=</span> console<span class="token punctuation">.</span>error<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>console<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> promise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\npromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">var</span> retPromise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n       <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"this promise is rejected"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> retPromise<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>前面说到了 <code class="language-text">Promise#then</code> 中的返回值会作为链式调用下一个方法中函数的参数。当返回的是一个 Promise 对象的时候，会等到该对象的状态变为 Fulfilled 或者 Rejected 之后进行下一步调用。</p>\n<h2>注意点</h2>\n<p>Promise 能很好地消化内容产生的错误，这也是需要注意的地方，因为错误不会从 Promise 中出来，但如果使用异步回调函数抛出的错误不会被 Promise 内部捕获，也就是会被抛出 Promise。</p>\n<h2>参考资料</h2>\n<ol>\n<li><a href="http://liubin.org/promises-book/">JavaScript Promise迷你书（中文版）</a></li>\n<li><a href="http://es6.ruanyifeng.com/">ECMAScript 6 入门 - Promise</a></li>\n</ol>',frontmatter:{title:"Promise",date:"August 21, 2016",tags:["前端","JavaScript"]},fields:{slug:"/promise/"}}},pathContext:{slug:"/promise/"}}}});
//# sourceMappingURL=path---posts-promise-bc2ed21a6d03d9764ea4.js.map
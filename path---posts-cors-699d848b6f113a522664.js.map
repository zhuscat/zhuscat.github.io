{"version":3,"sources":["webpack:///path---posts-cors-699d848b6f113a522664.js","webpack:///./.cache/json/posts-cors.json"],"names":["webpackJsonp","481","module","exports","data","markdownRemark","html","frontmatter","title","date","tags","fields","slug","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,s0RAAopQC,aAAw7BC,MAAA,UAAAC,KAAA,mBAAAC,MAAA,cAAiEC,QAAWC,KAAA,YAAkBC,aAAgBD,KAAA","file":"path---posts-cors-699d848b6f113a522664.js","sourcesContent":["webpackJsonp([72149548218910],{\n\n/***/ 481:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>虽然一直知道跨域，但也仅限于知道什么情况下会出现跨域的问题，没有实践过如何实现跨域。最近写代码正好碰到了需要跨域的需求，正好学习一下。实现跨域有很多种方法，常见的有 CORS，JSONP。这里我仅仅是说明如何使用 CORS 进行跨域。</p>\\n<h3>请求分类</h3>\\n<p>请求分为简单请求和非简单请求，满足以下条件的为简单请求，否则为非简单请求。</p>\\n<p>一、请求方法是以下几种</p>\\n<ol>\\n<li>HEAD</li>\\n<li>GET</li>\\n<li>POST</li>\\n</ol>\\n<p>二、HTTP的头信息不超出以下几种字段</p>\\n<p>（不包括 User Agent 自动增加的头部，如 <code class=\\\"language-text\\\">Connection</code>，<code class=\\\"language-text\\\">User-Agent</code>，详情见<a href=\\\"https://fetch.spec.whatwg.org/#forbidden-header-name\\\">forbidden-header-name</a>）</p>\\n<ol>\\n<li>Accept</li>\\n<li>Accept-Language</li>\\n<li>Content-Language</li>\\n<li>Last-Event-ID</li>\\n<li>Contnet-Type 为  <code class=\\\"language-text\\\">application/x-www-form-urlencoded</code>、<code class=\\\"language-text\\\">multipart/form-data</code>、<code class=\\\"language-text\\\">text/plain</code> 中的一个。</li>\\n</ol>\\n<h3>简单请求</h3>\\n<p>在简单请求的情况，浏览器在发出CORS请求头部中会自动增加一个 <code class=\\\"language-text\\\">Origin</code> 字段。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-http\\\"><code class=\\\"language-http\\\">GET / HTTP/1.1\\n<span class=\\\"token header-name keyword\\\">Origin:</span> http://localhost:6006\\n<span class=\\\"token header-name keyword\\\">Host:</span> localhost:8124\\n<span class=\\\"token header-name keyword\\\">Connection:</span> keep-alive\\n<span class=\\\"token header-name keyword\\\">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\\n<span class=\\\"token header-name keyword\\\">Accept-Language:</span> zh-CN,zh;q=0.8,en;q=0.6</code></pre>\\n      </div>\\n<p>如果 <code class=\\\"language-text\\\">Origin</code> 指定的源不在许可的范围里面，服务器就会返回一个正常的 HTTP 响应。如果浏览器发现回应的信息没有 <code class=\\\"language-text\\\">Access-Control-Allow-Origin</code> ，浏览器就会抛出一个错误，并会被 <code class=\\\"language-text\\\">XMLHttpRequest</code> 的 <code class=\\\"language-text\\\">onerror</code> 捕获。</p>\\n<p><strong>注意</strong>：此时 HTTP 返回码仍然可能是 200。</p>\\n<p>如果是允许返回的域，则服务器返回的字段中会有以下几个字段（其中，肯定会有 <code class=\\\"language-text\\\">Access-Control-Allow-Origin</code>，另外的两个根据相应情况而定。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-http\\\"><code class=\\\"language-http\\\"><span class=\\\"token response-status\\\">HTTP/1.1 <span class=\\\"token property\\\">200 OK</span></span>\\n<span class=\\\"token header-name keyword\\\">Access-Control-Allow-Origin:</span> http://localhost:6006\\n<span class=\\\"token header-name keyword\\\">Access-Control-Allow-Credentials:</span> true\\n<span class=\\\"token header-name keyword\\\">Access-Control-Expose-Headers:</span> X-Requested-With</code></pre>\\n      </div>\\n<p>(1) <code class=\\\"language-text\\\">Access-Control-Allow-Origin</code></p>\\n<p>表明允许的 <code class=\\\"language-text\\\">Origin</code>，当时 <code class=\\\"language-text\\\">*</code> 的时候表示接受任何域的请求。</p>\\n<p>(2) <code class=\\\"language-text\\\">Access-Control-Allow-Credentials</code></p>\\n<p>表明是否允许发送 <code class=\\\"language-text\\\">cookie</code>。允许下添加 <code class=\\\"language-text\\\">Access-Control-Allow-Credentials: true</code>，否则不包含该字段，该字段不能设置为 <code class=\\\"language-text\\\">false</code>。如果要浏览器发<code class=\\\"language-text\\\">cookie</code>，还需要浏览器方面做出一些配置。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token keyword\\\">const</span> xhr <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">XMLHttpRequest</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nxhr<span class=\\\"token punctuation\\\">.</span>withCredentials <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">true</span></code></pre>\\n      </div>\\n<p>这样就可以发送 <code class=\\\"language-text\\\">cookie</code> 了，另外需要注意的是，如果要发送 <code class=\\\"language-text\\\">cookie</code>，服务器返回的 <code class=\\\"language-text\\\">Access-Control-Allow-Origin</code> 不能是 <code class=\\\"language-text\\\">*</code>，必须是确定的域名。<code class=\\\"language-text\\\">cookie</code> 的传送依然遵循同源政策。</p>\\n<p>(3) <code class=\\\"language-text\\\">Acess-Control-Expose-Headers</code></p>\\n<p>可被 <code class=\\\"language-text\\\">getResponseHeader</code> 拿到的额外的字段。</p>\\n<p>本来就可以拿到的字段有：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">Cache-Control\\nContent-Language\\nContent-Type\\nExpires\\nLast-Modified\\nPragma</code></pre>\\n      </div>\\n<h3>非简单请求</h3>\\n<p>当发送非简单请求的时候，会先发送一个 <code class=\\\"language-text\\\">preflight</code> 请求，看这个请求是否被允许。</p>\\n<p>如下所示就是一个 <code class=\\\"language-text\\\">prefilight</code> 请求</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-http\\\"><code class=\\\"language-http\\\">OPTIONS / HTTP/1.1\\n<span class=\\\"token header-name keyword\\\">Host:</span> localhost:8124\\n<span class=\\\"token header-name keyword\\\">Connection:</span> keep-alive\\n<span class=\\\"token header-name keyword\\\">Access-Control-Request-Method:</span> POST\\n<span class=\\\"token header-name keyword\\\">Origin:</span> http://localhost:6006\\n<span class=\\\"token header-name keyword\\\">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\\n<span class=\\\"token header-name keyword\\\">Access-Control-Request-Headers:</span> x-requested-with\\n<span class=\\\"token header-name keyword\\\">Accept:</span> */*\\n<span class=\\\"token header-name keyword\\\">Referer:</span> http://localhost:6006/api\\n<span class=\\\"token header-name keyword\\\">Accept-Encoding:</span> gzip, deflate, sdch\\n<span class=\\\"token header-name keyword\\\">Accept-Language:</span> zh-CN,zh;q=0.8,en;q=0.6</code></pre>\\n      </div>\\n<p>注意到有两个特殊字段</p>\\n<p>(1) <code class=\\\"language-text\\\">Access-Control-Request-Method</code></p>\\n<p>表明该请求所用到的 HTTP 方法</p>\\n<p>(2) <code class=\\\"language-text\\\">Access-Control-Request-Headers</code></p>\\n<p>表明额外发送的头信息字段，这里是 <code class=\\\"language-text\\\">x-requested-with</code>，多个字段用逗号隔开。</p>\\n<p>如果服务器允许该跨域请求，会做出相应的回应。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-http\\\"><code class=\\\"language-http\\\"><span class=\\\"token response-status\\\">HTTP/1.1 <span class=\\\"token property\\\">200 OK</span></span>\\n<span class=\\\"token header-name keyword\\\">Content-Type:</span> application/json\\n<span class=\\\"token header-name keyword\\\">Access-Control-Allow-Origin:</span> *\\n<span class=\\\"token header-name keyword\\\">Access-Control-Allow-Headers:</span> X-Requested-With\\n<span class=\\\"token header-name keyword\\\">Access-Control-Allow-Methods:</span> GET, POST, PUT\\n<span class=\\\"token header-name keyword\\\">Date:</span> Thu, 13 Oct 2016 15:19:04 GMT\\n<span class=\\\"token header-name keyword\\\">Connection:</span> keep-alive\\n<span class=\\\"token header-name keyword\\\">Transfer-Encoding:</span> chunked</code></pre>\\n      </div>\\n<p>如果服务器返回普通的响应，则浏览器认为跨域不被允许，于是会抛出错误。</p>\\n<p>这里有几个新的字段之前没看到过</p>\\n<p>(1) <code class=\\\"language-text\\\">Access-Control-Allow-Headers</code></p>\\n<p>允许的额外头部</p>\\n<p>(2) <code class=\\\"language-text\\\">Access-Control-Allow-Methods</code></p>\\n<p>允许的 HTTP 请求方法</p>\\n<p>另外，还有可能会返回一下的字段</p>\\n<p>(1) <code class=\\\"language-text\\\">Access-Control-Allow-Credentials</code></p>\\n<p>(2) <code class=\\\"language-text\\\">Acess-Control-Max-Age</code></p>\\n<p>指明本次 <code class=\\\"language-text\\\">preflight</code> 的有效时间（秒），在有效时间内不用再次发送 <code class=\\\"language-text\\\">preflight</code> 请求。</p>\\n<p>接着浏览器就会发送正常的请求：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-http\\\"><code class=\\\"language-http\\\">POST / HTTP/1.1\\n<span class=\\\"token header-name keyword\\\">Host:</span> localhost:8124\\n<span class=\\\"token header-name keyword\\\">Connection:</span> keep-alive\\n<span class=\\\"token header-name keyword\\\">Content-Length:</span> 0\\n<span class=\\\"token header-name keyword\\\">Origin:</span> http://localhost:6006\\n<span class=\\\"token header-name keyword\\\">X-Requested-With:</span> X-Requested-With\\n<span class=\\\"token header-name keyword\\\">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\\n<span class=\\\"token header-name keyword\\\">Accept:</span> */*\\n<span class=\\\"token header-name keyword\\\">Referer:</span> http://localhost:6006\\n<span class=\\\"token header-name keyword\\\">Accept-Encoding:</span> gzip, deflate\\n<span class=\\\"token header-name keyword\\\">Accept-Language:</span> zh-CN,zh;q=0.8,en;q=0.6</code></pre>\\n      </div>\\n<p>接着服务器再返回请求</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-http\\\"><code class=\\\"language-http\\\"><span class=\\\"token response-status\\\">HTTP/1.1 <span class=\\\"token property\\\">200 OK</span></span>\\n<span class=\\\"token header-name keyword\\\">Content-Type:</span> application/json\\n<span class=\\\"token header-name keyword\\\">Access-Control-Allow-Origin:</span> *\\n<span class=\\\"token header-name keyword\\\">Date:</span> Thu, 13 Oct 2016 15:19:04 GMT\\n<span class=\\\"token header-name keyword\\\">Connection:</span> keep-alive\\n<span class=\\\"token header-name keyword\\\">Transfer-Encoding:</span> chunked</code></pre>\\n      </div>\\n<h3>参考资料</h3>\\n<ol>\\n<li><a href=\\\"http://www.ruanyifeng.com/blog/2016/04/cors.html\\\">跨域资源共享 CORS 详解</a></li>\\n<li><a href=\\\"http://tech.jandou.com/cross-domain.html\\\">前端跨域及其解决方案</a></li>\\n</ol>\\n<h3>更新记录</h3>\\n<ol>\\n<li>2017 年 8 月 16 日修改对简单请求的描述</li>\\n</ol>\",\"frontmatter\":{\"title\":\"CORS 跨域\",\"date\":\"October 14, 2016\",\"tags\":[\"前端\",\"HTTP\"]},\"fields\":{\"slug\":\"/cors/\"}}},\"pathContext\":{\"slug\":\"/cors/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---posts-cors-699d848b6f113a522664.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>虽然一直知道跨域，但也仅限于知道什么情况下会出现跨域的问题，没有实践过如何实现跨域。最近写代码正好碰到了需要跨域的需求，正好学习一下。实现跨域有很多种方法，常见的有 CORS，JSONP。这里我仅仅是说明如何使用 CORS 进行跨域。</p>\\n<h3>请求分类</h3>\\n<p>请求分为简单请求和非简单请求，满足以下条件的为简单请求，否则为非简单请求。</p>\\n<p>一、请求方法是以下几种</p>\\n<ol>\\n<li>HEAD</li>\\n<li>GET</li>\\n<li>POST</li>\\n</ol>\\n<p>二、HTTP的头信息不超出以下几种字段</p>\\n<p>（不包括 User Agent 自动增加的头部，如 <code class=\\\"language-text\\\">Connection</code>，<code class=\\\"language-text\\\">User-Agent</code>，详情见<a href=\\\"https://fetch.spec.whatwg.org/#forbidden-header-name\\\">forbidden-header-name</a>）</p>\\n<ol>\\n<li>Accept</li>\\n<li>Accept-Language</li>\\n<li>Content-Language</li>\\n<li>Last-Event-ID</li>\\n<li>Contnet-Type 为  <code class=\\\"language-text\\\">application/x-www-form-urlencoded</code>、<code class=\\\"language-text\\\">multipart/form-data</code>、<code class=\\\"language-text\\\">text/plain</code> 中的一个。</li>\\n</ol>\\n<h3>简单请求</h3>\\n<p>在简单请求的情况，浏览器在发出CORS请求头部中会自动增加一个 <code class=\\\"language-text\\\">Origin</code> 字段。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-http\\\"><code class=\\\"language-http\\\">GET / HTTP/1.1\\n<span class=\\\"token header-name keyword\\\">Origin:</span> http://localhost:6006\\n<span class=\\\"token header-name keyword\\\">Host:</span> localhost:8124\\n<span class=\\\"token header-name keyword\\\">Connection:</span> keep-alive\\n<span class=\\\"token header-name keyword\\\">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\\n<span class=\\\"token header-name keyword\\\">Accept-Language:</span> zh-CN,zh;q=0.8,en;q=0.6</code></pre>\\n      </div>\\n<p>如果 <code class=\\\"language-text\\\">Origin</code> 指定的源不在许可的范围里面，服务器就会返回一个正常的 HTTP 响应。如果浏览器发现回应的信息没有 <code class=\\\"language-text\\\">Access-Control-Allow-Origin</code> ，浏览器就会抛出一个错误，并会被 <code class=\\\"language-text\\\">XMLHttpRequest</code> 的 <code class=\\\"language-text\\\">onerror</code> 捕获。</p>\\n<p><strong>注意</strong>：此时 HTTP 返回码仍然可能是 200。</p>\\n<p>如果是允许返回的域，则服务器返回的字段中会有以下几个字段（其中，肯定会有 <code class=\\\"language-text\\\">Access-Control-Allow-Origin</code>，另外的两个根据相应情况而定。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-http\\\"><code class=\\\"language-http\\\"><span class=\\\"token response-status\\\">HTTP/1.1 <span class=\\\"token property\\\">200 OK</span></span>\\n<span class=\\\"token header-name keyword\\\">Access-Control-Allow-Origin:</span> http://localhost:6006\\n<span class=\\\"token header-name keyword\\\">Access-Control-Allow-Credentials:</span> true\\n<span class=\\\"token header-name keyword\\\">Access-Control-Expose-Headers:</span> X-Requested-With</code></pre>\\n      </div>\\n<p>(1) <code class=\\\"language-text\\\">Access-Control-Allow-Origin</code></p>\\n<p>表明允许的 <code class=\\\"language-text\\\">Origin</code>，当时 <code class=\\\"language-text\\\">*</code> 的时候表示接受任何域的请求。</p>\\n<p>(2) <code class=\\\"language-text\\\">Access-Control-Allow-Credentials</code></p>\\n<p>表明是否允许发送 <code class=\\\"language-text\\\">cookie</code>。允许下添加 <code class=\\\"language-text\\\">Access-Control-Allow-Credentials: true</code>，否则不包含该字段，该字段不能设置为 <code class=\\\"language-text\\\">false</code>。如果要浏览器发<code class=\\\"language-text\\\">cookie</code>，还需要浏览器方面做出一些配置。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token keyword\\\">const</span> xhr <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">XMLHttpRequest</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nxhr<span class=\\\"token punctuation\\\">.</span>withCredentials <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">true</span></code></pre>\\n      </div>\\n<p>这样就可以发送 <code class=\\\"language-text\\\">cookie</code> 了，另外需要注意的是，如果要发送 <code class=\\\"language-text\\\">cookie</code>，服务器返回的 <code class=\\\"language-text\\\">Access-Control-Allow-Origin</code> 不能是 <code class=\\\"language-text\\\">*</code>，必须是确定的域名。<code class=\\\"language-text\\\">cookie</code> 的传送依然遵循同源政策。</p>\\n<p>(3) <code class=\\\"language-text\\\">Acess-Control-Expose-Headers</code></p>\\n<p>可被 <code class=\\\"language-text\\\">getResponseHeader</code> 拿到的额外的字段。</p>\\n<p>本来就可以拿到的字段有：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-text\\\"><code class=\\\"language-text\\\">Cache-Control\\nContent-Language\\nContent-Type\\nExpires\\nLast-Modified\\nPragma</code></pre>\\n      </div>\\n<h3>非简单请求</h3>\\n<p>当发送非简单请求的时候，会先发送一个 <code class=\\\"language-text\\\">preflight</code> 请求，看这个请求是否被允许。</p>\\n<p>如下所示就是一个 <code class=\\\"language-text\\\">prefilight</code> 请求</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-http\\\"><code class=\\\"language-http\\\">OPTIONS / HTTP/1.1\\n<span class=\\\"token header-name keyword\\\">Host:</span> localhost:8124\\n<span class=\\\"token header-name keyword\\\">Connection:</span> keep-alive\\n<span class=\\\"token header-name keyword\\\">Access-Control-Request-Method:</span> POST\\n<span class=\\\"token header-name keyword\\\">Origin:</span> http://localhost:6006\\n<span class=\\\"token header-name keyword\\\">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\\n<span class=\\\"token header-name keyword\\\">Access-Control-Request-Headers:</span> x-requested-with\\n<span class=\\\"token header-name keyword\\\">Accept:</span> */*\\n<span class=\\\"token header-name keyword\\\">Referer:</span> http://localhost:6006/api\\n<span class=\\\"token header-name keyword\\\">Accept-Encoding:</span> gzip, deflate, sdch\\n<span class=\\\"token header-name keyword\\\">Accept-Language:</span> zh-CN,zh;q=0.8,en;q=0.6</code></pre>\\n      </div>\\n<p>注意到有两个特殊字段</p>\\n<p>(1) <code class=\\\"language-text\\\">Access-Control-Request-Method</code></p>\\n<p>表明该请求所用到的 HTTP 方法</p>\\n<p>(2) <code class=\\\"language-text\\\">Access-Control-Request-Headers</code></p>\\n<p>表明额外发送的头信息字段，这里是 <code class=\\\"language-text\\\">x-requested-with</code>，多个字段用逗号隔开。</p>\\n<p>如果服务器允许该跨域请求，会做出相应的回应。</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-http\\\"><code class=\\\"language-http\\\"><span class=\\\"token response-status\\\">HTTP/1.1 <span class=\\\"token property\\\">200 OK</span></span>\\n<span class=\\\"token header-name keyword\\\">Content-Type:</span> application/json\\n<span class=\\\"token header-name keyword\\\">Access-Control-Allow-Origin:</span> *\\n<span class=\\\"token header-name keyword\\\">Access-Control-Allow-Headers:</span> X-Requested-With\\n<span class=\\\"token header-name keyword\\\">Access-Control-Allow-Methods:</span> GET, POST, PUT\\n<span class=\\\"token header-name keyword\\\">Date:</span> Thu, 13 Oct 2016 15:19:04 GMT\\n<span class=\\\"token header-name keyword\\\">Connection:</span> keep-alive\\n<span class=\\\"token header-name keyword\\\">Transfer-Encoding:</span> chunked</code></pre>\\n      </div>\\n<p>如果服务器返回普通的响应，则浏览器认为跨域不被允许，于是会抛出错误。</p>\\n<p>这里有几个新的字段之前没看到过</p>\\n<p>(1) <code class=\\\"language-text\\\">Access-Control-Allow-Headers</code></p>\\n<p>允许的额外头部</p>\\n<p>(2) <code class=\\\"language-text\\\">Access-Control-Allow-Methods</code></p>\\n<p>允许的 HTTP 请求方法</p>\\n<p>另外，还有可能会返回一下的字段</p>\\n<p>(1) <code class=\\\"language-text\\\">Access-Control-Allow-Credentials</code></p>\\n<p>(2) <code class=\\\"language-text\\\">Acess-Control-Max-Age</code></p>\\n<p>指明本次 <code class=\\\"language-text\\\">preflight</code> 的有效时间（秒），在有效时间内不用再次发送 <code class=\\\"language-text\\\">preflight</code> 请求。</p>\\n<p>接着浏览器就会发送正常的请求：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-http\\\"><code class=\\\"language-http\\\">POST / HTTP/1.1\\n<span class=\\\"token header-name keyword\\\">Host:</span> localhost:8124\\n<span class=\\\"token header-name keyword\\\">Connection:</span> keep-alive\\n<span class=\\\"token header-name keyword\\\">Content-Length:</span> 0\\n<span class=\\\"token header-name keyword\\\">Origin:</span> http://localhost:6006\\n<span class=\\\"token header-name keyword\\\">X-Requested-With:</span> X-Requested-With\\n<span class=\\\"token header-name keyword\\\">User-Agent:</span> Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\\n<span class=\\\"token header-name keyword\\\">Accept:</span> */*\\n<span class=\\\"token header-name keyword\\\">Referer:</span> http://localhost:6006\\n<span class=\\\"token header-name keyword\\\">Accept-Encoding:</span> gzip, deflate\\n<span class=\\\"token header-name keyword\\\">Accept-Language:</span> zh-CN,zh;q=0.8,en;q=0.6</code></pre>\\n      </div>\\n<p>接着服务器再返回请求</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-http\\\"><code class=\\\"language-http\\\"><span class=\\\"token response-status\\\">HTTP/1.1 <span class=\\\"token property\\\">200 OK</span></span>\\n<span class=\\\"token header-name keyword\\\">Content-Type:</span> application/json\\n<span class=\\\"token header-name keyword\\\">Access-Control-Allow-Origin:</span> *\\n<span class=\\\"token header-name keyword\\\">Date:</span> Thu, 13 Oct 2016 15:19:04 GMT\\n<span class=\\\"token header-name keyword\\\">Connection:</span> keep-alive\\n<span class=\\\"token header-name keyword\\\">Transfer-Encoding:</span> chunked</code></pre>\\n      </div>\\n<h3>参考资料</h3>\\n<ol>\\n<li><a href=\\\"http://www.ruanyifeng.com/blog/2016/04/cors.html\\\">跨域资源共享 CORS 详解</a></li>\\n<li><a href=\\\"http://tech.jandou.com/cross-domain.html\\\">前端跨域及其解决方案</a></li>\\n</ol>\\n<h3>更新记录</h3>\\n<ol>\\n<li>2017 年 8 月 16 日修改对简单请求的描述</li>\\n</ol>\",\"frontmatter\":{\"title\":\"CORS 跨域\",\"date\":\"October 14, 2016\",\"tags\":[\"前端\",\"HTTP\"]},\"fields\":{\"slug\":\"/cors/\"}}},\"pathContext\":{\"slug\":\"/cors/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/posts-cors.json\n// module id = 481\n// module chunks = 72149548218910"],"sourceRoot":""}
webpackJsonp([0x9e3466f19da8],{498:function(t,n){t.exports={data:{markdownRemark:{html:'<p><img src="https://i.loli.net/2018/11/17/5befc20e79926.png" alt="Redux"></p>\n<p>Redux 是一个可预测的状态容器。最近看了 Redux 作者的入门视频，算是入了个门，顺便写篇文章记录一下。</p>\n<!-- more -->\n<h1>基本思想</h1>\n<p>首先是 action，action 是形如下面形式的 JavaScript 对象：</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">{\n\ttype: &#39;ACTION_TYPE&#39;,\n\tinfo: &#39;some information&#39;\n}</code></pre>\n      </div>\n<p>其中，type 是必须的，通过 action 可以改变状态。</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">(oldState, action) =&gt; newState</code></pre>\n      </div>\n<p>以上就是一个 reducer 了，输入一个旧的状态与动作，输出一下新的状态。Redux 要求我们不要去修改旧状态。</p>\n<p>通过 createStore 来创建一个 store，然后通过 dispatch 函数来修改 store 所存储的状态。</p>\n<p>可以 <code class="language-text">subscribe(listener)</code> 来监听状态的变化，当状态发生变化的时候调用 listener 来执行一些操作。</p>\n<p>另外还有一个 getState 方法可以获取当前状态</p>\n<p>所以 Redux 的基本思想是这样的：</p>\n<p>action 描述发生了什么，reducer 则根据 action 改变 state，store 则是将两者联系起来。</p>\n<p>接着就说说视频里的一些其他东西，比较杂。</p>\n<h1>有用的库</h1>\n<ol>\n<li>expect</li>\n<li>deep-freeze</li>\n</ol>\n<h1>不要修改原数组</h1>\n<p>Redux 要求我们不要去修改原来的状态，状态所包含的信息可以多种多样，比如说数组，所以我们要注意不要去修改原来的数组</p>\n<h2>添加</h2>\n<p>不要这样做</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">list.push(item);\nreturn list;</code></pre>\n      </div>\n<p>这样做</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">return [...list, item];</code></pre>\n      </div>\n<h2>删除某一项</h2>\n<p>不要这样做</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">list.splice(index, 1);</code></pre>\n      </div>\n<p>这样做</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">return [\n\t...list.slice(0, i),\n\t...list.slice(i + 1)\n\t];</code></pre>\n      </div>\n<h2>修改某一项</h2>\n<p>这样做</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">return [\n\t...list.slice(0, i),\n\tlist[i] + 1,\n\t...list.slice(i + 1)\n\t];</code></pre>\n      </div>\n<h1>不要修改原对象</h1>\n<p>使用 Object.assign，将键值赋值到第一个参数上，如果有一样的键的话，后面那个的值会被赋给第一个参数</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">return Object.assign({}, todo, {\n\tcompleted: !todo.completed\n\t});\n}</code></pre>\n      </div>\n<p>还有这样的方法，不过下面这种方法不是标准中的方法，不过 babel 支持转码</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">return {\n\t...todo,\n\tcompleted: !todo.completed\n\t};</code></pre>\n      </div>\n<h1>combineReducers 简要实现</h1>\n<p>combineReducers 可以将多个 reducer 整合起来变为一个 reducer</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">const combineReducers = (reducers) =&gt; {\n\treturn (state, action) =&gt; {\n\t\treturn Object.keys(reducers).reduce(\n\t\t\t(nextState, key) =&gt; {\n\t\t\t\tnextState[key] = reducers[key](\n\t\t\t\t\tstate[key],\n\t\t\t\t\taction\n\t\t\t\t);\n\t\t\t\treturn nextState;\n\t\t\t},\n\t\t\t{}\n\t\t);\n\t};\n};</code></pre>\n      </div>\n<h1>Provider 简要实现</h1>\n<p>使用 Provider 为自己的应用提供一个顶层状态，该状态向下流动给有需要的组件使用</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">class Provider extends Component {\n\tgetChildContext() {\n\t\treturn {\n\t\t\tstore: this.props.store\n\t\t};\n\t}\n\n\trender() {\n\t\treturn this.props.children;\n\t}\n}\n\nProvider.childContextTypes = {\n\tstore: React.PropTypes.object\n};</code></pre>\n      </div>\n<p>给需要用到 store 的组件加上：</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">SomeComponent.contextTypes = {\n\tstore: React.PropTypes.Object\n};</code></pre>\n      </div>\n<p>使用 context 把数据传递到所有的子组件</p>\n<p>作者把 contextTypes 比喻 wormhole，有需要的组件可以获取状态数据</p>\n<p>这些事情一个库已经帮我们做好了：</p>\n<p>react-redux</p>\n<h1>分离表现和行为</h1>\n<p>这是作者在视频后面做的事情，主要方法如下</p>\n<p>创建 Container Component</p>\n<p>提供数据，行为</p>\n<p>将数据行为与表现连接起来</p>\n<p>创建 Presentation Component</p>\n<p>决定组件是如何展现的，而不关心行为</p>\n<p>将表现组件从容器组件中分离出来</p>\n<p>分离出来的好处？</p>\n<p>一个好处是当不使用 Redux 管理状态的时候，不需要修改太多代码，也就是低耦合了</p>\n<p>然后分离了之后就发现所有 Container Component 都是类似的，react-redux 就提供了一个 connect 方法来创建容器组件，非常方便，用法如下：</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">// 定义生成的 Container Component 中 Presentation Component 的 props\n\nconst mapStateToProps = (state, ownProps) =&gt; {\n\treturn {\n\t\tfoo: state.foo\n\t};\n};\n\nconst mapStateToDispatch = (dispatch, ownProps) =&gt; {\n\treturn {\n\t\tonEventOccur: () =&gt; {\n\t\t\tdispatch({\n\t\t\t\ttype: SOME_ACTION\n\t\t\t})\n\t\t}\n\t};\n};\n\n// 生成\n\nconst ContainerComponent = connect(\n\tmapStateToProps,\n\tmapStateToDispatch)(PresentationComponent)</code></pre>\n      </div>\n<h1>结构</h1>\n<ol>\n<li>action</li>\n<li>reducers</li>\n<li>store</li>\n<li>\n<p>components</p>\n<ul>\n<li>Presentational Components</li>\n<li>Container Components</li>\n</ul>\n</li>\n</ol>',frontmatter:{title:"Redux 初体验",date:"July 22, 2016",tags:["前端","学习笔记","Redux","开发"]},fields:{slug:"/learn-redux/"}}},pathContext:{slug:"/learn-redux/"}}}});
//# sourceMappingURL=path---posts-learn-redux-4aca2456c8d810acc654.js.map
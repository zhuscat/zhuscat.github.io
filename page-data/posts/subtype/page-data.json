{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/subtype","result":{"data":{"site":{"siteMetadata":{"title":"ZhusCafe"}},"markdownRemark":{"html":"<h2>关于协变</h2>\n<p>协变类型保留底层类型之间的子类型关系</p>\n<p>如 <code class=\"language-text\">Triangle</code> 是 <code class=\"language-text\">Shape</code> 的子类，那么 <code class=\"language-text\">Triangle[]</code>也是<code class=\"language-text\">Shape[]</code>的子类，<code class=\"language-text\">LinkedList&lt;Triangle&gt;</code>是<code class=\"language-text\">LinkedList&lt;Shape&gt;</code>的子类。</p>\n<p>在大部分编程语言中，函数的返回值是协变的，如：</p>\n<p><code class=\"language-text\">() =&gt; Triangle</code> 是 <code class=\"language-text\">() =&gt; Shape</code> 的子类型</p>\n<h2>关于逆变</h2>\n<p>逆变是反转了底层类型之间的子类型关系\n在大部分编程语言中，函数的参数是逆变的，比如：</p>\n<p><code class=\"language-text\">(s: Shape) =&gt; void</code> 是 <code class=\"language-text\">(t: Triangle) =&gt; void</code> 的子类型，怎么理解？</p>\n<p>比如我用到一个类型为 <code class=\"language-text\">(t: Triangle) =&gt; void</code> 变量，我能做的事情是调用这个函数，传入一个 <code class=\"language-text\">Triangle</code> 类型的变量进行，那么 <code class=\"language-text\">(s: Shape) =&gt; void</code> 类型的变量赋值给 <code class=\"language-text\">(t: Triangle) =&gt; void</code> 会有问题吗，我们看看 <code class=\"language-text\">Triangle</code> 类型的变量能不能赋值给 <code class=\"language-text\">(s: Shape) =&gt; void</code>，结果是可以的，因为 <code class=\"language-text\">Triangle</code> 是 <code class=\"language-text\">Shape</code> 的子类，所以 <code class=\"language-text\">Shape</code> 有的属性/方法 <code class=\"language-text\">Triangle</code> 都有</p>\n<h3>双变</h3>\n<p>不过 TypeScript 中的函数具有双变性：</p>\n<p><a href=\"https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-function-parameters-bivariant\">https://github.com/Microsoft/TypeScript/wiki/FAQ#why-are-function-parameters-bivariant</a></p>\n<p>为什么这样设计呢？看上面链接中的一段代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">function</span> <span class=\"token function\">trainDog</span><span class=\"token punctuation\">(</span>d<span class=\"token operator\">:</span> Dog<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">cloneAnimal</span><span class=\"token punctuation\">(</span>source<span class=\"token operator\">:</span> Animal<span class=\"token punctuation\">,</span> <span class=\"token function-variable function\">done</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>result<span class=\"token operator\">:</span> Animal<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Cat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Runtime error here occurs because we end up invoking 'trainDog' with a 'Cat'</span>\n<span class=\"token function\">cloneAnimal</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> trainDog<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>像上面的代码是可以编译通过的，然而在运行时会造成一个错误，就是因为 TS 中函数是双变的，你可能觉得这样不合适，那么想一下，你觉得 <code class=\"language-text\">Triangle[]</code> 可以赋值给 <code class=\"language-text\">Shape[]</code> 吗？我们期望是可以的，否则很多地方的代码会变得非常烦人了。比如我们肯定希望 <code class=\"language-text\">Triangle[]</code> 可以作为 <code class=\"language-text\">drawShapes(shapes: Shape[]) =&gt; void</code> 的参数\n那这就要求 <code class=\"language-text\">Triangle[]</code> 的每个成员都需要能够赋值给 <code class=\"language-text\">Shape[]</code></p>\n<p>因为数组是有方法的，比如 <code class=\"language-text\">push</code> 方法，那么 <code class=\"language-text\">Triangle[].push</code> 需要可以赋值给 <code class=\"language-text\">Shape[].push</code>\n也就是说 <code class=\"language-text\">(x: Triangle) =&gt; number</code> 可以赋值给 <code class=\"language-text\">(x: Shape) =&gt; number</code></p>\n<p>如果上面的描述能够成立的话，这就不仅仅要求函数的参数具有逆变性，还需要有协变性，也就是说，TypeScript 的函数具有双变性，这是设计上的一种 Trade Off</p>\n<p>我们可以设置 TS 的<a href=\"https://www.typescriptlang.org/tsconfig/#strictFunctionTypes\">--strictFunctionTypes</a>开启函数子类型的强制性检查，这样函数参数就只能逆变了</p>","frontmatter":{"title":"协变、逆变、双向协变","date":"December 09, 2021","tags":["TypeScript","类型系统"]},"fields":{"slug":"/posts/subtype/"}}},"pageContext":{"slug":"/posts/subtype/"}},"staticQueryHashes":["3159585216"]}
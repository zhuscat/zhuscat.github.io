{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts/note-of-swifter","result":{"data":{"site":{"siteMetadata":{"title":"ZhusCafe"}},"markdownRemark":{"html":"<p>读了《SWITER 100个Swift必备Tips》，记录了一些东西。</p>\n<!-- more -->\n<ol>\n<li>将 <code class=\"language-text\">protocol</code> 的方法声明为 <code class=\"language-text\">mutating</code> ，可以改变 <code class=\"language-text\">struct</code> 或者 <code class=\"language-text\">enum</code> 中的属性值</li>\n<li>初始化方法顺序：先设置子类自己需要初始化的参数，再调用父类的初始化方法，最后调用父类中需要改变的参数</li>\n<li>在 <code class=\"language-text\">init?</code> 中可以对 <code class=\"language-text\">self</code> 赋值</li>\n<li>获取 <code class=\"language-text\">Self</code> 类型的实例， <code class=\"language-text\">self.dynamicType.init()</code> ，要求需要有 <code class=\"language-text\">required</code> 关键字修饰的初始化方法</li>\n<li>初始化方法对属性的设定，以及在 <code class=\"language-text\">willSet</code> 和 <code class=\"language-text\">didSet</code> 中对属性的再次设定都不会再次触发属性观察器的调用</li>\n<li>属性观察调用顺序 <code class=\"language-text\">get</code>（实现 <code class=\"language-text\">didSet</code> 时， 用来获取 oldValue) <code class=\"language-text\">willSet</code> <code class=\"language-text\">set</code> <code class=\"language-text\">didSet</code></li>\n<li>protocol extension 可以为 protocol 中定义的方法提供一个默认的实现。</li>\n<li>Swift 中是没有泛型接口(protocol)的，但是使用一个必须实现的别名，在一定程度上算是一种折衷</li>\n<li>添加编译符号：Build Settings -> Swift Compiler -> Custom Flags -> Other Swift Flags -> <code class=\"language-text\">-D FREE_VERSION</code></li>\n<li>如果 Class 是 NSObject 的子类，Swift 会默认自动为所有的非 private 的类和成员加上 <code class=\"language-text\">@objc</code></li>\n<li>用 <code class=\"language-text\">@objc(someName)</code> 来改变类或方法的名字（与 Objective-C 进行混编的时候 Objective-C 中的名字）</li>\n<li>在 Swift 2.0 之后，实现可选接口可以通过接口扩展的方式来实现</li>\n<li>在访问的时候不会已经被释放的话尽量使用 <code class=\"language-text\">unowned</code>，如果存在被释放的可能就用 <code class=\"language-text\">weak</code></li>\n<li>使用初始化方法(init)的话，就不需要面临自动释放的问题了，每次在超过作用域后，自动内存管理都将为我们处理好内存相关的事情</li>\n<li>C 中的 <code class=\"language-text\">const Type *</code> 对应于 Swift 中的 UnsafePointer，<code class=\"language-text\">Type *</code> 对应于 UnsafeMutablePointer</li>\n<li>调用 C 动态库，如果一个动态库暂时没有 module 化，可以使用桥接的形式使用</li>\n<li>字符串插值的时候将直接使用类型的 <code class=\"language-text\">Streamable</code>，<code class=\"language-text\">Printable</code>，<code class=\"language-text\">DebugPrintable</code> 接口，按照先后次序，前面没有使用用后面</li>\n<li>原来的 <code class=\"language-text\">NS_OPTIONS</code> 被映射为了满足 <code class=\"language-text\">OptionSetType</code> 接口的 <code class=\"language-text\">struct</code> 类型，以及一组静态的 <code class=\"language-text\">get</code> 属性</li>\n<li>对于原来的 <code class=\"language-text\">kNilOptions</code>，现在可以直接用一个空集合表示 <code class=\"language-text\">[]</code></li>\n<li>使用 <code class=\"language-text\">@asmname</code> 可以将某个C函数直接映射成Swift中的函数</li>\n<li>Swift的 <code class=\"language-text\">sizeofValue</code> 所返回的是这个值的实际大小，而不是内容的大小</li>\n<li>使用 <code class=\"language-text\">objc_getAssociatedObject</code> 和 <code class=\"language-text\">objc_setAssociatedObject</code> 在扩展中添加成员变量</li>\n<li><code class=\"language-text\">@synchronized</code> 在幕后做的事情是 调用了 <code class=\"language-text\">objc_sync</code> 中的 <code class=\"language-text\">objc_sync_enter</code> 和 <code class=\"language-text\">objc_sync_exit</code>，并加入了异常判断，在Swift中没有 <code class=\"language-text\">@synchronized</code></li>\n<li>在命令行输入 <code class=\"language-text\">xcrun swift</code> 进入 Swift 命令行工具</li>\n<li><code class=\"language-text\">arc4random</code> 所返回的值无论在什么平台上都是一个 <code class=\"language-text\">UInt32</code>，另一个方法 <code class=\"language-text\">arc4random_uniform</code> 接收一个 <code class=\"language-text\">UInt32</code> 的数字n，将结果归一化到 0 到 n - 1 之间</li>\n<li>调用 <code class=\"language-text\">print</code> 打印对象或结构体之类的，可以实现 <code class=\"language-text\">CustomStringConvertible</code> 和 <code class=\"language-text\">CustomDebugStringConvertible</code> 来自定义打印内容</li>\n<li>在 Swift 2 时代中的错误处理的最佳实践，对于同步API使用异常机制，对于异步API使用泛型枚举</li>\n<li>对应target -> Build Settings -> Swift Compiler -> Custom Flags -> Other Swift Flags -> 添加 -assert-config Debug 强制启用断言 -assert-config Release 强制禁用断言</li>\n<li>在遇到确实因为输入的错误无法使程序继续运行的时候，考虑以 <code class=\"language-text\">fatalError</code> 的形式终止程序</li>\n<li>安全的资源组织方式，使用 <code class=\"language-text\">enum</code> 或者 <code class=\"language-text\">struct</code>，一些成熟的自动化工具：R.swift、SwiftGen</li>\n<li>Playground 延时运行，<code class=\"language-text\">import XCPlayground</code>后，调用<code class=\"language-text\">XCPlaygroundPage.currentPage.needsIndefiniteExecution = true</code></li>\n<li>Log输出几个有用的编译符号：<code class=\"language-text\">#file</code> <code class=\"language-text\">#line</code> <code class=\"language-text\">#column</code> <code class=\"language-text\">#function</code></li>\n<li>使用溢出处理的运算符可以在溢出时程序不崩溃</li>\n<li>Swift 中的 <code class=\"language-text\">private</code> 是按文件限制范围的</li>\n<li>Swift 中专门为 Core Data 假如了 <code class=\"language-text\">@NSManaged</code></li>\n<li>闭包歧义跟多元组有关系</li>\n</ol>","frontmatter":{"title":"Swifter 读书笔记","date":"April 26, 2016","tags":["学习笔记","技术","开发","Swift","iOS"]},"fields":{"slug":"/posts/note-of-swifter/"}}},"pageContext":{"slug":"/posts/note-of-swifter/"}},"staticQueryHashes":["3159585216"]}